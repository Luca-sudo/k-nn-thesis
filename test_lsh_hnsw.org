#+title: Test LSH & HNSW

This script forms the backbone for comparing the quality of HNSW and LSH on instances.
It receives a filepath to the instance data as its sole argument.
Then, it reads the file and processes it.
Before we can do this, we first have to import any necessary library. To this end we use:
- Matplotlib to generate graphs of the benchmark-data
- Csv to write the benchmark data to a csv file
- sys to extract CLI arguments -- in this case the path to the data
- time to measure index creation and query times
- numpy to work with arrays
- h5py to read previously generated data
- faiss to create HNSW and LSH indexes.

#+begin_src python :tangle test_lsh_hnsw.py
#!/usr/bin/env python3
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import sys
import time
import numpy as np
import h5py
import faiss
#+end_src

With all libraries in place, we have to extract the filepath to the data from the CLI.

#+begin_src python :tangle test_lsh_hnsw.py
if(len(sys.argv) <= 1):
    raise Exception("Please supply a filepath for data to compare!")

filepath = sys.argv[1]
#+end_src

We then read the first parameters of the test data -- such as the number of instances, description and $k$ for nearest neighbour queries -- before printing an explanation of the hypothesis this data examines as well as a natural language description of the data.

#+begin_src python :tangle test_lsh_hnsw.py
file = h5py.File(filepath, 'r')
k = file.attrs['k'].item()
n_instances = file.attrs['n_instances']
description = file.attrs['description']
hypothesis = file.attrs['hypothesis']

print(f'Hypothesis: {hypothesis}')
print(f'Description: {description}')
#+end_src

Before testing each instance, we setup lists for all data that we are interested in. We initialize these lists with a short, descriptive string; this lets us write the data to a .csv file descriptively later on.

#+begin_src python :tangle test_lsh_hnsw.py
data_extraction = []
hnsw_creation = []
hnsw_querying = []
lsh_creation = []
lsh_querying = []
hnsw_min = []
hnsw_median = []
hnsw_max = []
lsh_min = []
lsh_median = []
lsh_max = []
hnsw_ranks = []
lsh_ranks = []
#+end_src

Finally, we begin evaluating all instances. For this we extract the data, which includes the dimensionality, amount of sites, optimal solutions to the k-nearest neighbour query, etc.

#+begin_src python :tangle test_lsh_hnsw.py
for i in range(n_instances):
    print(f'Extracting instance {i}.')
    time_start = time.perf_counter()
    dataset = file['instance_' + str(i)]
    n_dim = dataset.attrs['n_dims'].item()
    n_sites = dataset.attrs['n_sites']
    n_planes = dataset.attrs['n_planes'].item()
    print('n_planes: ', n_planes)
    sites = dataset[()]
    optimal_distances = file['distance_' + str(i)][()]
    ordered_sites = file['ordered_sites_' + str(i)][()]
    query = file['query_' + str(i)][()]
    solution = file['solution_' + str(i)][()]
    time_end = time.perf_counter()
    dt = round(time_end - time_start, 7)
    data_extraction.append(dt)
    print(f'\tExtracting data: \t{dt:.3f} seconds')
#+end_src

With the instance data at hand, we now create the HNSW index and time it.

#+begin_src python :tangle test_lsh_hnsw.py
    time_start = time.perf_counter()
    hnsw_index = faiss.IndexHNSWFlat(n_dim, 4)
    hnsw_index.hnsw.efConstruction = 200
    hnsw_index.add(sites)
    time_end = time.perf_counter()
    dt = round(time_end - time_start, 7)
    hnsw_creation.append(dt)
    print(f'\tCreating HNSW Index: \t{time_end - time_start:.3f} seconds')
#+end_src

We then query this HNSW index.

#+begin_src python :tangle test_lsh_hnsw.py
    time_start = time.perf_counter()
    hnsw_distance, hnsw_solutions = hnsw_index.search(query, k)
    time_end = time.perf_counter()
    dt = round(time_end - time_start, 7)
    hnsw_querying.append(dt)
    print(f'\tQuerying HNSW Index: \t{time_end - time_start:.3f} seconds')
#+end_src

Afterwards, we create the LSH index and query it too.

#+begin_src python :tangle test_lsh_hnsw.py
    time_start = time.perf_counter()
    lsh_index = faiss.IndexLSH(n_dim, n_planes)
    lsh_index.add(sites)
    time_end = time.perf_counter()
    dt = round(time_end - time_start, 7)
    lsh_creation.append(dt)
    print(f'\tCreating LSH Index: \t{time_end - time_start:.3f} seconds')

    time_start = time.perf_counter()
    _, lsh_solutions = lsh_index.search(query, k)
    time_end = time.perf_counter()
    dt = round(time_end - time_start, 7)
    lsh_querying.append(dt)
    print(f'\tQuerying LSH Index: \t{time_end - time_start:.3f} seconds')
#+end_src

Before we can evaluate the quality of the LSH index, we have to calculate the distances for candidate solutions manually. While the HNSW index returned euclidean distances together with the set of candidate solutions, LSH returns the hamming distance instead. We, therefore, calculate the euclidean distances for all LSH candidate solutions.

#+begin_src python :tangle test_lsh_hnsw.py
    solution_vectors = sites[lsh_solutions]
    lsh_distance = np.sum((solution_vectors[0] - query) ** 2, axis=1)
#+end_src

Next, we sort the resulting distances of both HNSW and LSH from best to worst, before we calculate the quality of the respective solutions. We define the quality of a candidate solution relative to the optimal solution through the formula $\frac{\text{Optimal Distance}}{\text{Achieved Distance}}$. Hence, the quality of a candidate is $1$ if it is precisely the optimal solution. In any other case, the quality approaches zero as the realized distance worsens.

#+begin_src python :tangle test_lsh_hnsw.py
    sorted_lsh_distances = sorted(lsh_distance)
    sorted_hnsw_distances = sorted(hnsw_distance[0])

    lsh_quality = optimal_distances / sorted_lsh_distances
    hnsw_quality = optimal_distances / sorted_hnsw_distances
#+end_src

Finally, we print and store the values of interest: minimum, median and maximum quality for both HNSW and LSH.


#+begin_src python :tangle test_lsh_hnsw.py
    print('\tLSH Min, Median, Max:\t\t', min(lsh_quality), lsh_quality[1], max(lsh_quality))
    print('\tHNSW Min, Median, Max:\t\t', min(hnsw_quality), hnsw_quality[1], max(hnsw_quality))

    hnsw_min.append(min(hnsw_quality))
    lsh_min.append(min(lsh_quality))
    hnsw_median.append(hnsw_quality[1])
    lsh_median.append(lsh_quality[1])
    hnsw_max.append(max(hnsw_quality))
    lsh_max.append(max(lsh_quality))
#+end_src

Besides the quality, the nearest neighbor order is of interest too. It is an integer $i$ that, for a given site $s$, denotes that $s$ is the $i$-th neighbor. To accelerate determining $i$, it suffices to index into the `ordered_sites_i` list. At position $s$ of the `ordered_sites_i` list -- note that faiss indices return index values into the original list of sites -- the corresponding $i$ can be extracted.

#+begin_src python :tangle test_lsh_hnsw.py
    current_lsh_ranks = ordered_sites[lsh_solutions]
    current_hnsw_ranks = ordered_sites[hnsw_solutions]

    lsh_ranks.append(current_lsh_ranks)
    hnsw_ranks.append(current_hnsw_ranks)

    print('\tLSH Ranks: ', current_lsh_ranks)
    print('\tHNSW Ranks: ', current_hnsw_ranks)
#+end_src

:TODO: Add section on csv and plot generation.

#+begin_src python :tangle test_lsh_hnsw.py
df = pd.DataFrame({
    'data_extraction' : data_extraction,
    'hnsw_creation' : hnsw_creation,
    'hnsw_query' : hnsw_querying,
    'lsh_creation' : lsh_creation,
    'lsh_query' : lsh_querying,
    'hnsw_min_quality' : hnsw_min,
    'hnsw_median_quality' : hnsw_median,
    'hnsw_max_quality' : hnsw_max,
    'lsh_min_quality' : lsh_min,
    'lsh_median_quality' : lsh_median,
    'lsh_max_quality' : lsh_max,
    'lsh_ranks' : lsh_ranks,
    'hnsw_ranks' : hnsw_ranks
});


csv_path = filepath + ".csv"

df.to_csv(csv_path)

fig_path = filepath + ".pdf"

fig, axes = plt.subplots(1, 3)

sns.lineplot(
    data=df[['lsh_min_quality', 'hnsw_min_quality']], ax=axes[0])
axes[0].set_title('Minimum Quality')

sns.lineplot(
    data=df[['lsh_median_quality', 'hnsw_median_quality']], ax=axes[1])
axes[1].set_title('Median Quality')

sns.lineplot(
    data=df[['lsh_max_quality', 'hnsw_max_quality']], ax=axes[2])
axes[2].set_title('Maximum Quality')

plt.savefig(fig_path)
plt.show()


#+end_src
